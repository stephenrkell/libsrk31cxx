#ifndef SRK31CXX_CLOSURE_HPP_
#define SRK31CXX_CLOSURE_HPP_

#include <memory>
#include <vector>
#include <cstring>
#include <cassert>
#include <type_traits>
#include <ffi.h>

/* This file contains template definitions that
 * generate boilerplate for libffi's closure API.
 * Specifically, they let you generate a function pointer
 * that calls a C++ member function on a specific object.
 * This is useful when you want to satisfy a C-style
 * callback API using a C++ object. If you don't see
 * a reason to do this, you don't need this file. */

namespace srk31
{

using std::unique_ptr;
using std::make_unique;
using std::vector;

/* libffi defines a bunch of descriptors for primitive types; we need to map
 * these to C++ primitive types. */
template <typename T, typename S = void>
struct ffi_type_s
{};
// all pointers are the same
template <typename T> struct ffi_type_s<T*> { static ffi_type *t() { return &ffi_type_pointer; } };
// libffi has no bool
template<> struct ffi_type_s<bool>            { static ffi_type *t() { return &ffi_type_sint8; } };
// what about enums? map all to sint32
template <typename T> struct ffi_type_s<T, typename std::enable_if<std::is_enum<T>::value>::type>
                                              { static ffi_type *t() { return &ffi_type_sint32; } };
// others transfer directly
template<> struct ffi_type_s<uint8_t>         { static ffi_type *t() { return &ffi_type_uint8; } };
template<> struct ffi_type_s< int8_t>         { static ffi_type *t() { return &ffi_type_sint8; } };
template<> struct ffi_type_s<uint16_t>        { static ffi_type *t() { return &ffi_type_uint16; } };
template<> struct ffi_type_s< int16_t>        { static ffi_type *t() { return &ffi_type_sint16; } };
template<> struct ffi_type_s<uint32_t>        { static ffi_type *t() { return &ffi_type_uint32; } };
template<> struct ffi_type_s< int32_t>        { static ffi_type *t() { return &ffi_type_sint32; } };
template<> struct ffi_type_s<uint64_t>        { static ffi_type *t() { return &ffi_type_uint64; } };
template<> struct ffi_type_s< int64_t>        { static ffi_type *t() { return &ffi_type_sint64; } };
template<> struct ffi_type_s<float>           { static ffi_type *t() { return &ffi_type_float; } };
template<> struct ffi_type_s<double>          { static ffi_type *t() { return &ffi_type_double; } };
template<> struct ffi_type_s<long double>     { static ffi_type *t() { return &ffi_type_longdouble; } };

/* Closure glue code specific to a particular class type and member function
 * signature is generated by this template. */
template <typename ClassType, typename RetType, typename... MemberFunArgs>
struct ffi_closure_s
{
	/* This is the type of (a pointer to) the member function that we
	 * want to generate a closure for. It's any member function. */
	typedef RetType (ClassType::*MemberFunPtrType)(MemberFunArgs...);

	/* All generated libffi closures do a similar thing: they slurp their
	 * arguments from the calling context's stack/registers, pack them into
	 * a block of memory, create an array of pointers to that memory, and
	 * dispatch to a function that looks like the below. That function then
	 * must unpack them and do the actual thing the closure is intended to
	 * do, e.g. our member function call, then write the return value on the end of
	 * another pointer. It's a lot of packing/unpacking. (I've a feeling
	 * one or the Ruby or Lua implementations sports a tracing-JITted version
	 * of this process?! Would be nice.)
	 *
	 * The comment below is from a mailing list post, since the actual closure
	 * API is barely documented.
	 * https://gcc.gnu.org/legacy-ml/java/1999-q3/msg00138.html
	 * https://gcc.gnu.org/legacy-ml/java/1999-q3/msg00174.html
	 *
	 * We just declare the function for now... see below for the definition.
	 */
// FIXME: figure out how to forward-declare static member functions -- this doesn't work
#if 0
	template <MemberFunPtrType member_fun_ptr>
	static void
	/* FN will receive the arguments
	 * CIF (the original cif),
	 * RVALUE (a pointer to the location into which to store the result),
	 * AVALUE (an array of pointers to  locations holding the arguments) and
	 * DATA (some user defined data that the callee can use to determine what
	 * do do about this call.)
	 *
	 * It might look like this, to dispatch to a concrete C++ member function.
		int ret = reinterpret_cast<myclass *>(data)->myfunction(
			*reinterpret_cast<float*>(avalue[0]),
			*reinterpret_cast<bool*>(avalue[1]));
		memcpy(rvalue, &ret, sizeof ret);
	 */
	the_fun(ffi_cif *cif, void *rvalue, void **avalue, void *data);
#endif

	/* To unpack arguments from the array of pointers into our actual
	 * bona fide C++ member function call, we use some template magic.
	 * First we generate a std::tuple from the array. Doing so is
	 * deceptively simple thanks to std::tie and the miracle of the
	 * '...' pattern expansion operator. Our caller will instantiate 'Is'
	 * with an ascending sequence of integers from zero.
	 *
	 * At first it's a bit mysterious how 'seq' gets expanded in unison
	 * with 'MemberFunArgs'. I think this is just the semantics of
	 * '...'-expansion of expressions with two or more template argument packs
	 * (here Is and MemberFunArgs)... they get expanded in lock-step. */
	template <std::size_t... Is>
	static
	std::tuple<MemberFunArgs...>
	get_tuple(void **avalue, std::index_sequence<Is...> seq)
	{
		return std::tie<MemberFunArgs...>(
			*reinterpret_cast<MemberFunArgs *>(avalue[ Is ])...
		);
	}

	/* Now we need a helper that can call a function given a tuple,
	 * i.e. make it into a bona fide argument pack. Again the ascending
	 * sequence of integers helps us, this time getting the nth item
	 * from the tuple. */
	template <std::size_t... Is>
	static
	RetType call_member_fun_with_tuple(
		ClassType *obj,
		MemberFunPtrType member_fun,
		const std::tuple < MemberFunArgs ... >& tuple,
		std::index_sequence<Is...> seq
	)
	{
		return (obj->*member_fun)(std::get<Is>(tuple)...);
	}

	/* Now we plumb these together into the actual function we promised. */
	template <MemberFunPtrType member_fun_ptr>
	static void
	the_fun(ffi_cif *cif, void *rvalue, void **avalue, void *data)
	{
		ClassType *obj =  reinterpret_cast<ClassType *>(data);
		*reinterpret_cast<RetType*>(rvalue) = call_member_fun_with_tuple(
			obj,
			member_fun_ptr,
			get_tuple(avalue, std::index_sequence_for<MemberFunArgs...>()),
			std::index_sequence_for<MemberFunArgs...>()
		);
	}

	/* If we're dynamically creating closures, how do they get destroyed?
	 * It seems reasonable to use std::unique_ptr.
	 *
	 * One quirk is that in the libffi API, the closure pointer (the
	 * start of the allocated blob) is distinct from the code pointer (the
	 * actual callable instructions). It's the closure pointer we need to
	 * free, but it's the code pointer that is most useful to client code.
	 *
	 * For now, we abuse the deleter... just use the deleter object to
	 * remember the closure pointer and any other state we need. Then the
	 * unique_ptr can pointer to the function, so we give it a function
	 * type.
	 *
	 * In our rag-bag of state on the deleter, we need the cif and type info.
	 * It's extravagant that they are two separate heap allocations, but it'll
	 * do for now. They need to live as long as the function lives. */
	struct closure_deleter {
		ffi_closure *closure;
		std::unique_ptr< vector<ffi_type *> > typevec;
		std::unique_ptr< ffi_cif > p_cif;
		closure_deleter() : closure(nullptr), typevec(nullptr), p_cif(nullptr) {}
		closure_deleter(ffi_closure *closure,
			std::unique_ptr< vector<ffi_type *> > &&typevec,
			std::unique_ptr<ffi_cif>&& p_cif)
		 : closure(closure), typevec(std::move(typevec)), p_cif(std::move(p_cif)) {}
		void operator()( RetType(*fp)(MemberFunArgs...) ) const
		{ if (closure) ffi_closure_free(closure); }
	};

	/* Now we actually have the ingredients necessary to call libffi and
	 * set up a brand new closure, passing the relevant template instance
	 * that generates our 'the_fun'. We created templates above  */
	template <MemberFunPtrType member_fun>
	static unique_ptr< RetType(MemberFunArgs...), closure_deleter > make_closure(ClassType *obj)
	{
		RetType(*fp)(MemberFunArgs...);
		ffi_closure *closure = reinterpret_cast<ffi_closure*>(
			ffi_closure_alloc(sizeof (ffi_closure), (void**) &fp)
		);
		ffi_status status;
		auto p_atypes = make_unique<std::vector<ffi_type *> >(
			(std::vector<ffi_type *>) {ffi_type_s<MemberFunArgs>::t()...}
		);
		auto p_cif = make_unique<ffi_cif>();
		status = ffi_prep_cif(&*p_cif,
			/* ffi_abi abi */ FFI_DEFAULT_ABI,
			/*unsigned int nargs */ p_atypes->size(),
			/* ffi_type *rtype */ ffi_type_s<RetType>::t(),
			/* ffi_type **atypes */ &(*p_atypes)[0]
		);
		if (status != FFI_OK) throw 1; // FIXME: better thing to throw (or return null?)
		status = ffi_prep_closure(closure, &*p_cif, &the_fun<member_fun>, obj);
		if (status != FFI_OK) throw 1;  // FIXME: better thing to throw (or return null?)
		return std::unique_ptr< RetType(MemberFunArgs...), closure_deleter >
			(fp, closure_deleter(closure, std::move(p_atypes), std::move(p_cif)));
	}
};
/* Convenience typedef: given a member function,
 * figure out which instance of ffi_closure_f we need. */
template <typename ArbitraryT>
struct member_fun_typedef
{};
template <typename RetT, typename ClassT, typename... ArgTs>
struct member_fun_typedef< RetT (ClassT::*)(ArgTs...) >
{
	typedef ffi_closure_s<ClassT, RetT, ArgTs...> t;
};

} /* end namespace srk31 */

#endif

#ifdef SRK31CXX_CLOSURE_TEST

#include <iostream>

/* example */
class myclass
{
	/* add a member var to check the closure's 'this' pointer works */
	int z;
public:
	myclass() : z(0) {}
	int get_z() const { return z; }
	/* 'myfunction' is the member function we'll create a closure for */
	int myfunction(float x, bool double_it) { ++z; return (int) (double_it ? x*2 : x); }
} o;

int main(void)
{
	/* An ffi_closure is basically
	 * char tramp[FFI_TRAMPOLINE_SIZE];
	 * ffi_cif   *cif;
	 * void (*fun)(ffi_cif*,void*,void**,void*);
	 * void *user_data;
	 *
	 * ... where 'fun' is called as commented above.
	 */

	std::unique_ptr<int(float, bool), srk31::ffi_closure_s<myclass, int, float, bool>::closure_deleter > fp
	 = srk31::ffi_closure_s<myclass, int, float, bool>::make_closure<&myclass::myfunction>(&o);
	assert(fp);
	std::cout << "z is " << o.get_z() << std::endl;
	std::cout << "Called the function (doubling? no) and got " << (*fp)(42.0, false) << std::endl;
	std::cout << "z is " << o.get_z() << std::endl;
	std::cout << "Called the function (doubling? yes) and got " << (*fp)(42.0, true) << std::endl;
	return 0;
}

#endif
